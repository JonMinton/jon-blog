{
  "hash": "a6f64e1f52455a13b4a2ebc5bdaf560a",
  "result": {
    "markdown": "---\ntitle: \"Tidy Tuesday Extra - Packages and recursive searching\"\nauthor: \n  - \"Jon Minton\"\ndate: \"2024-04-20\"\n---\n\n\n\n## Introduction \n\n[The latest tidytuesday dataset](https://github.com/rfordatascience/tidytuesday/tree/master/data/2024/2024-04-16) contains information on R packages and how they're related to each other. The relationship information they contain poses some interesting challenges and opportunities. I (Jon), foolishly and/or sadistically, suggested trying to build a recursive algorithm which, given a given package, traces out the other packages that either depends on it, or that it depends on. \n\nWe didn't quite get where we were hoping to, but hopefully in this post I'll be able to unpack some of the challenges and opportunities this approach could bring.\n\nUnlike most tidy tuesday challenges, my (horrible) suggestion brought us into the land of computer science, rather than the data science challenges that most tidy tuesday sessions tend to be focused on. Rather than cover what we did and didn't achieve in that session, this post is largely my attempt to think through the challenge of building and developing a recursive function in R for allowing us to trace through a tree starting from a given node. The post isn't intended to *solve* the challenge I initially suggested, but to lay out some of the conceptual groundwork required to do so later. \n\n## Recursion as a concept \n\nA [recursive function](https://www.geeksforgeeks.org/recursive-functions/) is a function that conditionally evokes itself. It's a beautiful and horrifying idea -  coding Inception - and as the link above suggests is often used when a more complex problem needs to be broken down into ever smaller steps. The fifth example in the above link says that it's great for exploring and parsing tree and graph structures. And indeed that's the kind of application I was thinking about when I saw the TidyTuesday dataset. \n\nI've only found reason to build a recursive algorithm in R once before, perhaps around a decade ago. My problem was that I had a two dimensional regular matrix of values, but some of the cells contained missing values. I wanted to build a function that, for any missing value in the matrix, would impute a value for the missing cell given the average of the values in the eight cells that surrounded it, something known as a [Moore Neighbourhood](https://en.wikipedia.org/wiki/Moore_neighborhood). The Wikipedia example image used is as follows:\n\n![Moore Neighbourhood](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Moore_neighborhood_with_cardinal_directions.svg/1920px-Moore_neighborhood_with_cardinal_directions.svg.png)\n\nIf each missing cell $C$ was surrounded only by non-missing cells, then there would have been no need for recursion. However there were examples in the data where two or more *contiguous*/neighbouring cells cells were missing. I used recursion to solve this problem by calling the imputation function on any missing neighbours (Say $NE$) of the missing target cell $C$. The missing neighbour cell would then become the new target cell $C$, and if any of this target cell's neighbours were missing, then the imputation function would be called once again, with the last stage's neighbour cell now the new target cell. Only if the condition that a target cell has no missing neighbours would the imputation function actually impute. \n\nIn effect, this use of recursion meant that, for a *patch* of missing cells, the imputation would occur *outside-to-inside*, i.e. from the cell with the most non-missing neighbours to the cell with the fewest. \n\nAnyway, with that example in mind, let's look at the data.\n\n## Loading the data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.0     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n\n```{.r .cell-code}\nlibrary(tidytuesdayR)\n\ndta_list <- tidytuesdayR::tt_load(2024, week = 16)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n--- Compiling #TidyTuesday Information for 2024-04-16 ----\n--- There are 2 files available ---\n--- Starting Download ---\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tDownloading file 1 of 2: `shiny_revdeps.csv`\n\tDownloading file 2 of 2: `package_details.csv`\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: One or more parsing issues, call `problems()` on your data frame for details,\ne.g.:\n  dat <- vroom(...)\n  problems(dat)\n```\n:::\n\n\n::: {.cell-output .cell-output-stderr}\n```\n--- Download complete ---\n```\n:::\n\n```{.r .cell-code}\ndta_main <- dta_list$shiny_revdeps\ndta_main\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 146,135 × 3\n   child              dependency_type parent\n   <chr>              <chr>           <chr> \n 1 AFheritability     depends         shiny \n 2 AMPLE              depends         shiny \n 3 animalEKF          depends         shiny \n 4 bde                depends         shiny \n 5 BDP2               depends         shiny \n 6 BoneProfileR       depends         shiny \n 7 clinDR             depends         shiny \n 8 CLME               depends         shiny \n 9 cocktailApp        depends         shiny \n10 competitiontoolbox depends         shiny \n# ℹ 146,125 more rows\n```\n:::\n:::\n\n\nOf course we didn't notice the dataset was focused on shiny! \n\n## Exploration\n\nWhat are the types of dependency listed?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunique(dta_main$dependency_type)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"depends\"   \"imports\"   \"suggests\"  \"linkingto\"\n```\n:::\n:::\n\n\nSo, where the parent is shiny, how many types of each dependency are there? \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndta_main %>% \n  filter(parent == \"shiny\") %>% \n  count(dependency_type)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  dependency_type     n\n  <chr>           <int>\n1 depends            78\n2 imports           793\n3 suggests          305\n```\n:::\n:::\n\n\nIs shiny its own parent?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndta_main %>% \n  filter(parent == \"shiny\") |>\n  filter(child == \"shiny\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 0 × 3\n# ℹ 3 variables: child <chr>, dependency_type <chr>, parent <chr>\n```\n:::\n:::\n\n\nNo, fortunately. \n\nDoes the dataset contain examples where shiny is neither the parent nor the child?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndta_main |>\n  filter(parent != \"shiny\" & child != \"shiny\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 144,928 × 3\n   child                 dependency_type parent  \n   <chr>                 <chr>           <chr>   \n 1 FAMetA                depends         LipidMS \n 2 teal.modules.clinical depends         teal    \n 3 teal.modules.general  depends         teal    \n 4 dartR                 depends         adegenet\n 5 dartR.base            depends         adegenet\n 6 dartR.captive         depends         adegenet\n 7 dartR.data            depends         adegenet\n 8 dartR.popgen          depends         adegenet\n 9 dartR.sim             depends         adegenet\n10 dartR.spatial         depends         adegenet\n# ℹ 144,918 more rows\n```\n:::\n:::\n\n\nYes it does. \n\n## Defining a problem \n\nAs we've finally looked enough at the dataset and documentation to know that shiny is the root, let's work out how many packages are children where dependency type is imports and parent is shiny.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndta_main |>\n  filter(parent == \"shiny\" & dependency_type == \"imports\") |>\n  count(child) |>\n  nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 793\n```\n:::\n:::\n\n\nThere appear to be 793 packages that have this relationship. \n\nLet's say we want to take this list of 793 packages and find all packages that have them as children.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_children <- function(parent_name) {\n    dta_main |> \n    filter(parent == parent_name) |> \n    filter(dependency_type == \"imports\") |> \n    pull(child) |> \n    unique()\n}\n\nchild_shiny <- get_children(\"shiny\")\n\nlength(child_shiny)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 793\n```\n:::\n:::\n\n\nThere are almost 15000 packages with this relationship as children. \n\nWe can now start to think about the recursive search problem by running the get_children function for each child package, with the name of the child now the name of the parent. \n\nLet's start with the five first packages who are direct children of shiny. \n\n::: {.cell}\n\n```{.r .cell-code}\nsome_shiny_children <- child_shiny[1:5]\n\nsome_shiny_grandchildren <- some_shiny_children |>\n  map(~get_children(.))\n\nsome_shiny_children\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"ABACUS\"        \"abstractr\"     \"activAnalyzer\" \"AdaptGauss\"   \n[5] \"adaptiveGPCA\" \n```\n:::\n\n```{.r .cell-code}\nsome_shiny_grandchildren\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\ncharacter(0)\n\n[[2]]\ncharacter(0)\n\n[[3]]\ncharacter(0)\n\n[[4]]\n[1] \"DistributionOptimization\" \"opGMMassessment\"         \n[3] \"scapGNN\"                  \"Umatrix\"                 \n\n[[5]]\ncharacter(0)\n```\n:::\n:::\n\n\nFor packages 1, 2, 3 and 5 there are no further children. However for package four there are four packages that are children. \n\nLet's see if the children of package 4 themselves have children.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngreat_grandchildren <- some_shiny_grandchildren[[4]] |>\n  map(~get_children(.))\n\ngreat_grandchildren\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"opGMMassessment\"\n\n[[2]]\n[1] \"EDOtrans\"\n\n[[3]]\ncharacter(0)\n\n[[4]]\ncharacter(0)\n```\n:::\n:::\n\n\nTwo of the great grandchildren have children. \n\n## Recursive search with a toy example\n\nLet's try to think through the fundamentals of a recursive function using a toy example. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntoy_data <- tribble(\n    ~parent, ~child, \n    \"A\", \"B\",\n    \"A\", \"C\",\n    \"A\", \"D\",\n    \"B\", \"E\",\n    \"C\", \"F\",\n    \"C\", \"G\",\n    \"G\", \"J\",\n    \"E\", \"H\",\n    \"E\", \"I\"\n)\n```\n:::\n\n\nThis dataset shows the following set of relationships:\n\n\n\n```{mermaid}\nflowchart TB\n\nA --> B\nA --> C\nA --> D\nB --> E\nC --> F\nC --> G\nG --> J\nE --> H\nE --> I\n\n```\n\n\nLet's first see if we can identify which of these nodes are roots. i.e. nodes that are children but have no parents. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_root <- function(df, node_label){\n    res <- df |> filter(parent == node_label) |> nrow()\n\n    if(res == 0){\n        return(TRUE)\n    } else {\n        return(FALSE)\n    }\n}\n```\n:::\n\n\nLet's test this for each of the nodes in the toy dataset. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nall_nodes <- unique(c(toy_data$parent, toy_data$child))\n\n\n# run manually for a couple of examples:\n\nis_root(toy_data, \"A\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis_root(toy_data, \"B\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis_root(toy_data, \"D\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis_root(toy_data, \"F\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n# run using functional programming \n\nroots <-  \n  sapply(all_nodes, function(x) is_root(toy_data, x))\n\nroots\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    A     B     C     G     E     D     F     J     H     I \nFALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE \n```\n:::\n:::\n\n\nNext we want to use the is_root() function inside a find_roots() function that will return all the roots in a dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfind_roots <- function(df){\n    all_nodes <- unique(c(df$parent, df$child))\n    \n    roots <-  \n      sapply(all_nodes, function(x) is_root(df, x))\n    \n    return(all_nodes[roots])\n}\n\nfind_roots(toy_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"D\" \"F\" \"J\" \"H\" \"I\"\n```\n:::\n:::\n\n\n\n## Recursive Root Finding Function\n\nLet's now think through a `trace_to_root` function, that uses recursion, and how it will work. \n\n- If `trace` is null, then start trace with `node`\n- If `node` is root, then return trace\n- If `node` is not root, then add each child to a trace, and rerun `trace_to_root` with the current node and trace parameters.\n\nAs part of debugging and development, I've added an option `verbose`, which reports on what the function is doing at each step. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrace_to_root <- function(node, trace = NULL, df, verbose = FALSE){\n    if (verbose){\n      message(\"Current node is \", node)\n      message(\"Current trace is \", trace)\n    }\n   \n    if (is.null(trace)){\n        trace <- list(node)\n    }\n\n    if (is_root(df, node)){\n        if (verbose) {\n          message(\"node \", node, \" is a root, so returning trace\")\n        }\n        return(trace)\n    } else {\n        if (verbose) {\n          message(\"node \", node, \" is not a root, so continuing\")\n        }\n\n        children <- df |> filter(parent == node) |> pull(\"child\")\n\n        if (verbose) {\n          message(\"have found \", length(children), \" children of \", node)\n        }\n\n        pass_down <- function(child, trace, verbose = TRUE) {\n            if (verbose) {message(\"current child is \", child)}\n            trace <- c(trace, child)\n            if (verbose) {message(\"trace is \", trace)}\n            return(trace_to_root(child, trace, df = df, verbose = verbose))\n        }\n        # This is where recursion happens\n        return(\n          map2(children, trace, pass_down)\n        )\n\n    }\n}\n```\n:::\n\n\nAs with many complex functions, this was developed through a number of steps, most of which involved extensive debugging and brow-furrowing. The use of the toy example and the graph, along with the verbose mode, made it easier to see whether the function was doing what I wanted it to, even if what it returns isn't necessarily in the nicest format. \n\nLet's start with node 'H', which should be identified as a root, with no further children. This should mean the number of operations performed and reported should be short:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrace_to_root(\"H\", df = toy_data, verbose = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent node is H\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent trace is \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nnode H is a root, so returning trace\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"H\"\n```\n:::\n:::\n\n\nThis seems to work as expected. Node 'D' should be similarly simple:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrace_to_root(\"D\", df = toy_data, verbose = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent node is D\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent trace is \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nnode D is a root, so returning trace\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"D\"\n```\n:::\n:::\n\n\nOne step up in complexity/number of operations should be node G, which will be the first use-case that will involve some recursion.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrace_to_root(\"G\", df = toy_data, verbose = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent node is G\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent trace is \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nnode G is not a root, so continuing\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nhave found 1 children of G\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ncurrent child is J\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ntrace is GJ\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent node is J\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent trace is GJ\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nnode J is a root, so returning trace\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"G\" \"J\"\n```\n:::\n:::\n\n\nThe list returned contains two elements, the first of which is G, and the second of which is J. This is the correct trace sequence. \n\nNow let's look at node E\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrace_to_root(\"E\", df = toy_data, verbose = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent node is E\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent trace is \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nnode E is not a root, so continuing\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nhave found 2 children of E\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ncurrent child is H\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ntrace is EH\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent node is H\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent trace is EH\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nnode H is a root, so returning trace\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ncurrent child is I\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ntrace is EI\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent node is I\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent trace is EI\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nnode I is a root, so returning trace\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"E\" \"H\"\n\n[[2]]\n[1] \"E\" \"I\"\n```\n:::\n:::\n\n\nThis time the outer list is of length two, each of whcih containing two elements. The first sublist denotes the path E to H, and the second the path E to I. Once again this first with what we know about the part of the tree starting at E: it splits into two paths. \n\nNow node C:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrace_to_root(\"C\", df = toy_data, verbose = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent node is C\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent trace is \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nnode C is not a root, so continuing\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nhave found 2 children of C\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ncurrent child is F\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ntrace is CF\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent node is F\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent trace is CF\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nnode F is a root, so returning trace\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ncurrent child is G\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ntrace is CG\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent node is G\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent trace is CG\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nnode G is not a root, so continuing\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nhave found 1 children of G\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ncurrent child is J\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ntrace is CJ\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent node is J\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent trace is CJ\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nnode J is a root, so returning trace\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ncurrent child is J\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ntrace is GJ\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent node is J\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent trace is GJ\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nnode J is a root, so returning trace\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"C\" \"F\"\n\n[[2]]\n[[2]][[1]]\n[1] \"C\" \"J\"\n\n[[2]][[2]]\n[1] \"G\" \"J\"\n```\n:::\n:::\n\n\nThe list object contains two sublists. The first sublist indicates the path C to F. The second sublist itself contains two sublists: one denoting a path C to J; the second of which denotes a path G to J. \n\nNow let's look at the tree as a whole, i.e. start at node A:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrace_to_root(\"A\", df = toy_data, verbose = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent node is A\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent trace is \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nnode A is not a root, so continuing\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nhave found 3 children of A\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ncurrent child is B\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ntrace is AB\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent node is B\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent trace is AB\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nnode B is not a root, so continuing\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nhave found 1 children of B\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ncurrent child is E\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ntrace is AE\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent node is E\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent trace is AE\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nnode E is not a root, so continuing\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nhave found 2 children of E\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ncurrent child is H\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ntrace is AH\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent node is H\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent trace is AH\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nnode H is a root, so returning trace\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ncurrent child is I\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ntrace is EI\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent node is I\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent trace is EI\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nnode I is a root, so returning trace\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ncurrent child is E\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ntrace is BE\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent node is E\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent trace is BE\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nnode E is not a root, so continuing\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nhave found 2 children of E\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ncurrent child is H\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ntrace is BH\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent node is H\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent trace is BH\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nnode H is a root, so returning trace\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ncurrent child is I\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ntrace is EI\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent node is I\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent trace is EI\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nnode I is a root, so returning trace\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ncurrent child is C\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ntrace is AC\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent node is C\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent trace is AC\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nnode C is not a root, so continuing\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nhave found 2 children of C\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ncurrent child is F\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ntrace is AF\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent node is F\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent trace is AF\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nnode F is a root, so returning trace\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ncurrent child is G\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ntrace is CG\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent node is G\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent trace is CG\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nnode G is not a root, so continuing\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nhave found 1 children of G\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ncurrent child is J\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ntrace is CJ\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent node is J\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent trace is CJ\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nnode J is a root, so returning trace\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ncurrent child is J\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ntrace is GJ\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent node is J\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent trace is GJ\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nnode J is a root, so returning trace\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ncurrent child is D\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ntrace is AD\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent node is D\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCurrent trace is AD\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nnode D is a root, so returning trace\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[[1]][[1]]\n[[1]][[1]][[1]]\n[1] \"A\" \"H\"\n\n[[1]][[1]][[2]]\n[1] \"E\" \"I\"\n\n\n[[1]][[2]]\n[[1]][[2]][[1]]\n[1] \"B\" \"H\"\n\n[[1]][[2]][[2]]\n[1] \"E\" \"I\"\n\n\n\n[[2]]\n[[2]][[1]]\n[1] \"A\" \"F\"\n\n[[2]][[2]]\n[[2]][[2]][[1]]\n[1] \"C\" \"J\"\n\n[[2]][[2]][[2]]\n[1] \"G\" \"J\"\n\n\n\n[[3]]\n[1] \"A\" \"D\"\n```\n:::\n:::\n\n\nThis structure is more complex. At the outer level there is a list of length three. \n\n\n## Conclusion\n\nBroadly, it appears the information contained in the list structures would allow the tree structure to be recovered. However, currently no trace returned is of length greater than 2. Before applying a recursive algorithm to the real data, more work should probably be done on defining exactly what type of output should be returned, and then implementing this return type. However, the function does appear to use recursion effectively, delving into various tree structures until roots of the trees are found, rather than either just stopping at an arbitrary depth, or never stopping and evaluating. ",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}